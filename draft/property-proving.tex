
Let $G_{\mathtt{f}} = \langle V, E, \textmd{cmd} \rangle$ be the
control flow graph for the function $\mathtt{f}$ and $S[\bullet]$ an
array of function summaries. In order to check whether the function
summary $S[{\mathtt{f}}]$ for $\mathtt{f}$ specifies the relation 
between the formal parameters and return values of $\mathtt{f}$, 
we define another control flow graph
$\hat{G}_{\mathtt{f}}^S = \langle V, E \hat{\textmd{cmd}}
\rangle$ where
\begin{equation*}
  \begin{array}{rcl}
    \hat{\textmd{cmd}} (\ell, \ell') & = &
    \left\{
      \begin{array}{ll}
        \overline{\mathtt{x}} := 
        \overline{\mathtt{nondet}};
        \mathtt{assume\ S[{\mathtt{g}}]}[
        \overline{\mathtt{u}} \mapsto \overline{E},
        \mathtt{\overline{ret}^g} \mapsto \overline{\mathtt{x}}]    
        &
        \textmd{ if } \textmd{cmd} (\ell, \ell') = 
        \overline{\mathtt{x}} := \mathtt{g} (\overline{E})\\
        \mathtt{\overline{ret}^f} := \overline{F}
        &
        \textmd{ if } \textmd{cmd} (\ell, \ell') = \mathtt{return\ }
        \overline{F}
      \end{array}
    \right.
  \end{array}
\end{equation*}

The control flow graph $\hat{G}_{\mathtt{f}}^S$ replaces every
function call in $G_{\mathtt{f}}$ by instantiating a function
summary. Using the proof rule for recursive functions, we have the
following proposition:
\begin{proposition}
  Let $G_{\mathtt{f}}$ be the control flow graph for the function
  $\mathtt{f}$, and $S[\bullet]$ an array of logic formulae over the formal
  parameters and return variables of each function. If $\assert{\top}\
  \hat{G}_{\mathtt{g}}^S\ \assert{S[\mathtt{g}]}$ for every
  function $\mathtt{g}$, then $\assert{\top}\ \mathtt{\overline{ret}^f} :=
  \mathtt{f} (\overline{\mathtt{u}})\ \assert{S[\mathtt{f}]}$.
\end{proposition}

It is easy to check $\assert{\top}\ \hat{G}^S_{\mathtt{g}}\
\assert{S[\mathtt{g}]}$ by program analysis. Let $G_{\mathtt{f}}$ be
the control flow graph for the function $\mathtt{f}$ and
$\hat{G}^S_{\mathtt{f}} = \langle V, E, \hat{\textmd{cmd}} \rangle$ as
above. Consider another control flow graph $\tilde{G}^S_{\mathtt{f}} =
\langle \tilde{V}, \tilde{E}, \tilde{\textmd{cmd}} \rangle$ where
\begin{equation*}
  \begin{array}{rcl}
    \tilde{V} & = & V \cup \{ \tilde{\ell}_e \}\\
    \tilde{E} & = & E \cup \{ (\ell_e, \tilde{\ell}_e) \}\\
    \tilde{\textmd{cmd}} (\ell, \ell') & = &
    \left\{
      \begin{array}{ll}
        \hat{\textmd{cmd}} (\ell, \ell') & 
        \textmd{ if } (\ell, \ell') \in E\\
        \mathtt{assert\ } S[\mathtt{f}] &
        \textmd{ if } (\ell, \ell') = (\ell_e, \tilde{\ell}_e)
      \end{array}
    \right.
  \end{array}
\end{equation*}

\begin{corollary}
  Let $G_{\mathtt{f}}$ be the control flow graph for the function
  $\mathtt{f}$, and $S[\bullet]$ an array of logic formulae over the formal
  parameters and return variables of each function. If $\textsc{BasicChecker}
  (\tilde{G}^S_{\mathtt{g}})$ returns $\mathit{Pass}$ for every function
  $\mathtt{g}$, then $\assert{\top}\ \mathtt{\overline{ret}^f} :=
  \mathtt{f} (\overline{\mathtt{u}})\ \assert{S[\mathtt{f}]}$.
  \label{corollary:check-summary}
\end{corollary}

\begin{algorithm}
  \KwIn{$G = \langle V, E, \textmd{cmd} \rangle$ : a control flow
    graph; $S[\bullet]$ : an array of function summaries}
  \KwOut{$\top$ if all function summaries are valid; $\bot$ otherwise}
  \ForEach{function $\mathtt{g}$}
  {
    \lIf{$\textsc{BasicChecker} (\tilde{G}^S_{\mathtt{g}}) \neq
      \mathit{Pass}$}
    {
      \Return $\bot$\;
    }
  }
  \Return $\top$\;
  \caption{$\textmd{CheckSummary} (G, S)$}
  \label{algorithm:check-summary}
\end{algorithm}