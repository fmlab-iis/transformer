We first define the rename function $\textsc{rename}(G)$. It returns a CFG $(V^i, E^i,\textmd{cmd}^i, \overline{u}^i, \overline{r}^i,\ell_s^i,\ell_e^i)$ obtained by first replacing every return command $\mathtt{return}\ \overline{E}$ by assignments to return variables $\overline{r} := \overline{E}$ and then renaming all variables and locations in $G$ with a fresh index value $i$. The function $\textsc{unwind}(G)$ returns a CFG $G'$ obtained by replacing all function call edges in $G$ with the CFG of the called function after renaming. In order to help exacting summaries from the $G'$, $\textsc{unwind}(G)$ annotates in $G'$ the entry and exit locations ${\ell_s^i}$ and ${\ell_e^i}$ of the unwounded functions $\fun{f}$ with an additional superscript $\fun{f}$, i.e., $\ell_s^{i,\fun{f}}$ and $\ell_e^{i,\fun{f}}$. The formal definition is given below.

Given a CFG $G=\langle
V, E,\textmd{cmd}, \overline{u}, \overline{r},{\ell_s},{\ell_e} \rangle$.
We use $\hat{E} =\{e\in E: \textmd{cmd} (e)= (\overline{x}:=\mathtt{g}(\overline{a}))\}$ to denote the set of function call edges in $E$ and define a function $\textsc{toCFG}(e)$ that maps a call edge $e$ of function $\fun{g}$ to a CFG returned from $\textsc{rename}(G_\fun{g})$. Notice that two different call edges of the same function are mapped to two different renamed CFGs. If no location with superscript $\fun{g}$ appears in $V$, $\textsc{toCFG}(e)$ returns a CFG with entry and exit locations annotated with superscript $\fun{g}$.

Formally, $\textsc{unwind}(G) = \langle V', E',\textmd{cmd}', \overline{u}, \overline{r},{\ell_s},{\ell_e} \rangle$ such that (1) $V' = V\cup \bigcup\{V^i:(\ell, \ell')\in \hat{E} \wedge \textsc{toCFG}(\ell, \ell')= \langle V^i, E^i,\textmd{cmd}^i, \overline{u}^i, \overline{r}^i,s,e\rangle \}$ (2) $E'= E \setminus \hat{E} \cup \bigcup\{E^i\cup\{(\ell, s),(e, \ell')\}: (\ell, \ell')\in \hat{E} \wedge \textsc{toCFG}(\ell, \ell')= \langle V^i, E^i,\textmd{cmd}^i, \overline{u}^i, \overline{r}^i,s,e\rangle \}$ with $s\in \{\ell_s^i,\ell_s^{i,\fun{f}}\}$, $e\in \{\ell_e^i,\ell_e^{i,\fun{f}}\}$, $\textmd{cmd}' (\ell, s) = (\overline{u}:=\overline{a})$, and $\textmd{cmd}' (e, \ell') = (\overline{x}:=\overline{r})$.


%$\textsc{unwind}(G) = \langle
%V', E' \rangle$ such that 
%(1) For all edges $(\ell, \ell')\in E$ with $\textmd{cmd} (\ell, \ell')=$



\hide{
\begin{algorithm}
  \KwIn{$G = \langle V, E \rangle$ : a control flow graph}
  $V' \leftarrow V$\;
  $E' \leftarrow E$\;
  \ForEach{$(\ell, \ell')\in E$ with $\textmd{cmd} (\ell, \ell')= x_1,\ldots,x_n:=\mathtt{f}(E_1, \ldots, E_n)$}
  {
  	Let $G_f$ b
  
    \uIf {\textsc{BasicChecker} ($\underline{G}_k$) =
      $\mathit{ErrorTrace} (\tau)$}
    {
      \tcp{find an error trace in the under-approximation $\underline{G}_k$}
      \Return $\mathit{ErrorTrace} (\tau)$\;
    }
    \uElseIf {\textsc{BasicChecker} ($\overline{G}_k$) =
      $\mathit{Pass}$}
    {
      \tcp{prove all assertions in the over-approximation $\overline{G}_k$}
      \Return $\mathit{Pass}$\;
    }
    \uElse {
      $G_{k+1} \leftarrow $ unwind $G_k$\;
      $k \leftarrow k + 1$\;
    }
  }
  \caption{The $\textsc{unwind}(G)$ function}
  \label{algorithm:unwind}
\end{algorithm}
}

\begin{proposition}
  Let $G$ be a control flow graph, $P$ and $Q$ logic formulae with
  free variables over program variables of $G$. $\assert{P}\ G\ 
  \assert{Q}$ if and only if $\assert{P}\ \textsc{unwind} (G)\ \assert{Q}$.
\end{proposition}