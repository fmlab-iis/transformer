Given a CFG $G=\langle
V, E,\textmd{cmd} \rangle$. The rename function $\textsc{rename}(G)$ returns a 5-tuple $(G^i, \bar{f}^i, \bar{r}^i,\ell_s^i,\ell_e^i)$ where $G^i$ is a CFG obtained by renaming all variables and locations in $G$ with a fresh index value $i$, $\bar{f}^i$ and $\bar{r}^i$ are formal parameters and return variables of $G^i$, and $\ell_s^i,\ell_e^i$ are the renamed entry and exit locations. The function $\textsc{unwind}(G)$ returns a CFG $G'$ obtained by replacing all function call edges in $G$ with the CFG of the called function after renaming. In order to help exacting summaries from the $G'$, $\textsc{unwind}(G)$ annotates in $G'$ the entry and exit locations ${\ell_s^i}$ and ${\ell_e^i}$ of the unwounded functions $f$ with superscript $(f)$, i.e., ${\ell_s^i}^{(f)}$ and ${\ell_e^i}^{(f)}$. The formal definition is given below.

Given a function $\mathtt{f}$ with CFG $G_f=\langle
V_f, E_f,\textmd{cmd}_f \rangle$.
Let $\hat{E} =\{e\in E: \textmd{cmd} (e)= \bar{x}:=\mathtt{f}(\bar{a})\}$ be the set of function call edges in $E$ and define a function $\textsc{toCFG}(e)$ that maps a call edge $e$ of function $f$ to a 5-tuple $\textsc{rename}(G_f)$. Notice that two different call edges of the same function are mapped to two different 5-tuples. If no location with superscript $(f)$ appear in $V$, $\textsc{toCFG}(e)$ returns a 5-tuple with entry and exit locations annotated with superscript $(f)$.

Formally, $\textsc{unwind}(G) = \langle V', E',\textmd{cmd}' \rangle$ such that (1) $V' = V\cup \bigcup\{V^i: e\in \hat{E} \wedge \textsc{toCFG}(e)= (\langle V^i, E^i,\textmd{cmd}^i \rangle, \bar{f}^i, \bar{r}^i,s,e) \}$ (2) $E'= E \setminus \hat{E} \cup \bigcup\{E_f\cup\{(\ell, s),(e, \ell')\}: (\ell, \ell')\in \hat{E} \wedge \textsc{toCFG}(\ell, \ell')= (\langle V^i, E^i,\textmd{cmd}^i \rangle, \bar{f}^i, \bar{r}^i,s,e) \}$ with $s\in \{\ell_s^i,{\ell_s^i}^{(f)}\}$, $e\in \{\ell_e^i,{\ell_e^i}^{(f)}\}$, $\textmd{cmd}' (\ell, {\ell_s^i}) = (\bar{a}=\bar{f})$, and $\textmd{cmd}' ({\ell_e^i}, \ell') = (\bar{x}=\bar{r})$.


%$\textsc{unwind}(G) = \langle
%V', E' \rangle$ such that 
%(1) For all edges $(\ell, \ell')\in E$ with $\textmd{cmd} (\ell, \ell')=$



\hide{
\begin{algorithm}
  \KwIn{$G = \langle V, E \rangle$ : a control flow graph}
  $V' \leftarrow V$\;
  $E' \leftarrow E$\;
  \ForEach{$(\ell, \ell')\in E$ with $\textmd{cmd} (\ell, \ell')= x_1,\ldots,x_n:=\mathtt{f}(E_1, \ldots, E_n)$}
  {
  	Let $G_f$ b
  
    \uIf {\textsc{BasicChecker} ($\underline{G}_k$) =
      $\mathit{ErrorTrace} (\tau)$}
    {
      \tcp{find an error trace in the under-approximation $\underline{G}_k$}
      \Return $\mathit{ErrorTrace} (\tau)$\;
    }
    \uElseIf {\textsc{BasicChecker} ($\overline{G}_k$) =
      $\mathit{Pass}$}
    {
      \tcp{prove all assertions in the over-approximation $\overline{G}_k$}
      \Return $\mathit{Pass}$\;
    }
    \uElse {
      $G_{k+1} \leftarrow $ unwind $G_k$\;
      $k \leftarrow k + 1$\;
    }
  }
  \caption{The $\textsc{unwind}(G)$ function}
  \label{algorithm:unwind}
\end{algorithm}
}

\begin{proposition}
  Let $G$ be a control flow graph, $P$ and $Q$ logic formulae with
  free variables over program variables of $G$. $\assert{P}\ G\ 
  \assert{Q}$ if and only if $\assert{P}\ \textsc{unwind} (G)\ \assert{Q}$.
\end{proposition}