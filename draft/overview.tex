
Let \textsc{BasicChecker} denote a recursion-free inductive program
checker and $G = \langle V, E \rangle$ a control flow graph. Since
non-recursive functions can be replaced by their control flow graphs
after proper variable renaming, we assume that $G$ only contains the
$\mathtt{main()}$ and recursive functions. If $G$ does not contain
recursive functions, \textsc{BasicChecker} is able to check $G$ by
computing inductive invariants.

When $G$ contains recursive functions, we transform $G$ into two
recursion-free programs $\underline{G}$ and $\overline{G}$. The
program $\underline{G}$ under-approximates the computation of
$G$. That is, every computation of $\underline{G}$ is also a
computation of $G$. If \textsc{BasicChecker} finds an error trace in
$\underline{G}$, our algorithm terminates and reports the error
trace. The program $\overline{G}$ on the other hand over-approximates
the compuation of $G$; every computation of $G$ is also a computation
of $\overline{G}$. If \textsc{BasicChecker} proves
that all assertions in $\overline{G}$ are satisfied, our algorithm
terminates and reports that all assertions in $G$ are satisfied. If
\textsc{BasicChecker} fails to prove assertions in $\overline{G}$, our
algorithm refines the under-approximation by unwinding recursive functions
and reiterates~(Algorithm~\ref{algorithm:overview}). 

\begin{algorithm}
  \KwIn{$G = \langle V, E \rangle$ : a control flow graph}
  $k \leftarrow 0$\;
  $G_0 \leftarrow G$\;
  \Repeat{forever}
  {
    \uIf {\textsc{BasicChecker} ($\underline{G}_k$) =
      $\mathit{ErrorTrace} (\tau)$}
    {
      \tcp{find an error trace in $G$}
      \Return $\mathit{ErrorTrace} (\tau)$\;
    }
    \uElseIf {\textsc{BasicChecker} ($\overline{G}_k$) =
      $\mathit{Pass}$}
    {
      \tcp{all computation of $G$ has been considered}
      \Return $\mathit{Pass}$\;
    }
    \uElse {
      $G_{k+1} \leftarrow $ unwind $G_k$\;
      $k \leftarrow k + 1$\;
    }
  }
  \caption{Overview}
  \label{algorithm:overview}
\end{algorithm}

To see how to under approximate computation, consider a control flow
graph $G_k$ with recursive functions $f_0 (\ox_0), f_1 (\ox_1),
\ldots, f_m (\ox_m)$. The under-approximation $\underline{G}_k$ is
obtained by substituting the command $\mathtt{assume\ false}$ for
every command with recursive function calls
(Figure~\ref{figure:under-mccarthy91}). The substitution
effectively blocks all recursive invocations. Any computation of
$\underline{G}_k$ hence is also a computation of $G_k$. Note that
$\underline{G}_k$ is recursion-free. \textsc{BasicChecker} is able to
check the under-approximation $\underline{G}_k$.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.3\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at (0, 0) {$\ell_s$}; %[label=above:$\mathtt{main()}$]
      \node[node] (1) at (0, -1) {$\ell_1$};
      \node[node] (2) at (0, -2) {$\ell_2$};
      \node[node] (3) at (0, -3) {$\ell_3$};
      \node[node] (4) at (0, -4) {$\ell_e$};

      \path
        (0) edge 
            node [left] {$\mathtt{assume\ n >= 0}$} (1)
        (1) edge 
            node [left] {$\mathtt{assume\ false}$} (2)
        (2) edge 
            node [left] {$\mathtt{assert\ r >= 91}$} (3)
        (3) edge 
            node [left] {$\mathtt{return\ 0}$} (4);
    \end{tikzpicture}
    \caption{$\mathtt{\underline{main}()}$}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{.6\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_e$};

      \path
        (0) edge [bend right=30]
            node [left] {$\mathtt{assume\ m > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(m > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{return\ m - 10}$} (5)
        (2) edge 
            node [right] {$\mathtt{assume\ false}$} (3)
        (3) edge 
            node [right] {$\mathtt{assume\ false}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{return\ t}$} (5);
    \end{tikzpicture}
    \caption{$\mathtt{\underline{mc91}(m)}$}
  \end{subfigure}
  \caption{Under Approximation of McCarthy 91}
  \label{figure:under-mccarthy91}
\end{figure}


To construct the over-approximation $\overline{G}_k$ from a
recursive control flow graph $G_k$, we maintain a summary for each
recursive function. For each recursive function $\mathtt{f}$ with $h$
return values, we introduce a set of \emph{return variables} 
$\mathtt{ret^f_1}, \mathtt{ret^f_2}, \ldots, \mathtt{ret^f_h}$ to
denote return values. Informally, a summary $S_{\mathtt{f}}$ is a
first-order 
conjunctive formula which specifies the relation between formal
parameters and return variables of the recursive function
$\mathtt{f}$. Initially, the summary $S_{\mathtt{f}}$ is set to
$\mathtt{true}$. The initial summary thus does not enforce any
relation between formal parameters and return values of recursive
functions. To construct $\overline{G}_k$, we replace every recursive
function call $\mathtt{x_1}, \mathtt{x_2}, \ldots, \mathtt{x_h} :=
\mathtt{f} (E_0, E_1, \ldots, E_l)$ by 
\begin{equation*}
  \begin{array}{l}
    \mathtt{x_1}, \ldots, \mathtt{x_h} :=
    \mathtt{nondet}, \ldots, \mathtt{nondet};\\
    \mathtt{assume}\ S_f[\mathtt{u_0} \mapsto E_0, \ldots, 
    \mathtt{u_l} \mapsto E_l, 
    \mathtt{ret^f_1} \mapsto \mathtt{x_1}, \ldots,
    \mathtt{ret^f_h} \mapsto \mathtt{x_h}]
  \end{array}
\end{equation*}
where $\mathtt{u_0}, \mathtt{u_1}, \ldots, \mathtt{u_l}$
are the formal parameters of the recursive function
$\mathtt{f}$ (Figure~\ref{figure:over-mccarthy91}).
The replacement effectively enforce the relation between formal
parameters and return values specified in the summary. Any computation
of $G_k$ is hence a computation of $\overline{G}_k$. Observe that
$\overline{G}_k$ is recursion-free. \textsc{BasicChecker} is able to
check the over-approximation $\overline{G}_k$.

\begin{figure}
  \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (s) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_5$};
      \node[node] (e) at ( 0, -5) {$\ell_e$};

      \path
        (s) edge [bend right=30]
            node [left] {$\mathtt{assume\ m > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(m > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{ret^{mc91}_0 := m - 10}$} (5)
        (2) edge 
            node [right] {$
              \begin{array}{l}
              \mathtt{s := nondet;}\\
              \mathtt{assume\ true}
              \end{array}
              $} (3)
        (3) edge 
            node [right] {$
              \begin{array}{l}
              \mathtt{t := nondet;}\\
              \mathtt{assume\ true}
              \end{array}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{ret^{mc91}_0 := t}$} (5)
        (5) edge 
            node [right] {$\mathtt{assert\ true}$} (e)
        ;
    \end{tikzpicture}
  \caption{Check Summary in McCarthy 91}
  \label{figure:check-summary-mccarthy91}
\end{figure}

In order to refine approximations, our algorithm unwinds recursive
functions as usual. More precisely, consider a recursive function
$\mathtt{f}$ with formal parameters $\mathtt{u_0}, \mathtt{u_1},
\ldots, \mathtt{u_l})$ and $h$ return values. Let $G_{\mathtt{f}}$ be
the control flow graph of $\mathtt{f}$ and $G_k$ a control flow graph
that invokes $\mathtt{f}$. To unwind $\mathtt{f}$ in $G_k$, 
we first construct a control flow graph $H_{\mathtt{f}}$ by 
replacing every $\mathtt{return}\ F_1, F_2, \ldots, F_h$ command in
$\mathtt{f}$ with the assignment $\mathtt{ret^f_1}, \mathtt{ret^f_2}, \ldots,
\mathtt{ret^f_h} := F_1, F_2, \ldots, F_h$. For each edge $(\ell,
\ell')$ labeled with the command $\mathtt{x_1}, \mathtt{x_2}, \ldots,
\mathtt{x_h} := \mathtt{f}(E_0, E_1, \ldots, E_l)$ in $G_k$, we remove
the edge $(\ell, \ell')$, make a fresh $H'_{\mathtt{f}}$ by
renaming every nodes and variables in $H_{\mathtt{f}}$, add an edge
from $\ell$ to the entry node of $H'_{\mathtt{f}}$ that assigns $E_0,
E_1, \ldots, E_l$ to fresh copies of formal parameters in
$H'_{\mathtt{f}}$, and another edge from the exit node to $\ell'$ that
assigns fresh copies of return variables to $\mathtt{x_1},
\mathtt{x_2}, \ldots, \mathtt{x_h}$. The control flow graph $G_{k+1}$
is obtained by unwinding every function calls in $G_k$. 
Figure~\ref{figure:unwind-mccarthy91} shows the control flow graph
$\mathtt{mc91_1(m)}$ by unwinding $\mathtt{mc91(m)}$. Note that the
unwinding graph $G_{k+1}$ still has recursive function calls. Its
approximations $\underline{G}_{k+1}$ and $\overline{G}_{k+1}$ however
are more informative than $\underline{G}_k$ and $\overline{G}_k$
respectively. 

\begin{figure}
  \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (s) at (-1,  0) {$\ell_s$};
      \node[node] (1) at (-2, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (e) at (-1, -4) {$\ell_e$};

      \node[node] (s') at ( 5,  2.6) {$\ell_{s'}$};
      \node[node] (1') at ( 4,  0.6) {$\ell_{1'}$};
      \node[node] (2') at ( 6,  1.8) {$\ell_{2'}$};
      \node[node] (3') at ( 6,  0.6) {$\ell_{3'}$};
      \node[node] (4') at ( 6, -0.6) {$\ell_{4'}$};
      \node[node] (e') at ( 5, -1.4) {$\ell_{e'}$};

      \node[node] (s'') at ( 5, -2.6) {$\ell_{s''}$};
      \node[node] (1'') at ( 4, -4.6) {$\ell_{1''}$};
      \node[node] (2'') at ( 6, -3.4) {$\ell_{2''}$};
      \node[node] (3'') at ( 6, -4.6) {$\ell_{3''}$};
      \node[node] (4'') at ( 6, -5.8) {$\ell_{4''}$};
      \node[node] (e'') at ( 5, -6.6) {$\ell_{e''}$};

      \path
        (s) edge [bend right=30]
            node [left] {$
              \begin{array}{c}
                \mathtt{assume}\\ 
                \mathtt{m > 100}                
              \end{array}$} (1)
            edge [bend left=20]
            node [above] {$
              \begin{array}{c}
                \mathtt{assume}\\
                \mathtt{not(m > 100)}
              \end{array}$} (2)
        (1) edge [bend right=30]
            node [left] {$
              \begin{array}{c}
                \mathtt{return}\\
                \mathtt{m - 10}
              \end{array}$} (e)
        (2) edge [bend left=50]
            node [above left] {$\mathtt{m' := m + 11}$} (s')
        (3) edge 
            node [below] {$\mathtt{m'' := s}$} (s'')
        (4) edge [bend left=30]
            node [below] {$\mathtt{return\ t}$} (e)

        (s') edge [bend right=30]
             node [left] {$
               \begin{array}{c}
                 \mathtt{assume}\\
                 \mathtt{m' > 100}
               \end{array}$} (1')
             edge [bend left=30]
             node [right] {$\mathtt{assume\ not(m' > 100)}$} (2')
        (1') edge [bend right=30]
             node [left] {$\mathtt{ret^{mc91'}_0 := m' - 10}$} (e')
        (2') edge 
             node [right] {$\mathtt{s' := mc91(m'+11)}$} (3')
        (3') edge 
             node [right] {$\mathtt{t' := mc91(s')}$} (4')
        (4') edge [bend left=30]
            node [right] {$\mathtt{ret^{mc91'}_0 := t'}$} (e')
        (e') edge 
             node [above] {$\mathtt{s := ret^{mc91'}_0}$} (3)

        (s'') edge [bend right=30]
              node [left] {$\mathtt{assume\ m'' > 100}$} (1'')
              edge [bend left=30]
              node [right] {$\mathtt{assume\ not(m'' > 100)}$} (2'')
        (1'') edge [bend right=30]
              node [left] {$
                \begin{array}{c}
                \mathtt{ret^{mc91''}_0 :=}\\
                \mathtt{m'' - 10}  
                \end{array}
                $} (e'')
        (2'') edge 
              node [right] {$\mathtt{s'' := mc91(m''+11)}$} (3'')
        (3'') edge 
              node [right] {$\mathtt{t'' := mc91(s'')}$} (4'')
        (4'') edge [bend left=30]
              node [right] {$\mathtt{ret^{mc91''}_0 := t''}$} (e'')
        (e'') edge [bend left=50]
              node [below left] {$\mathtt{t := ret^{mc91''}_0}$} (4)
        ;
    \end{tikzpicture}
  \caption{$\mathtt{mc91_1(m)}$}
  \label{figure:unwind-mccarthy91}
\end{figure}

