
Let \textsc{BasicChecker} denote a recursion-free inductive program
checker and $G = \langle V, E \rangle$ a control flow graph. Since
non-recursive functions can be replaced by their control flow graphs
after proper variable renaming, we assume that $G$ only contains the
$\mathtt{main()}$ and recursive functions. If $G$ does not contain
recursive functions, \textsc{BasicChecker} is able to check $G$ by
computing inductive invariants.

When $G$ contains recursive functions, we transform $G$ into two
recursion-free programs $\underline{G}$ and $\overline{G}$. The
program $\underline{G}$ under-approximates the computation of
$G$. That is, every computation of $\underline{G}$ is also a
computation of $G$. If \textsc{BasicChecker} finds an error trace in
$\underline{G}$, our algorithm terminates and reports the error
trace. The program $\overline{G}$ on the other hand over-approximates
the computation of $G$; every computation of $G$ is also a computation
of $\overline{G}$. If \textsc{BasicChecker} proves that all assertions
in $\overline{G}$ are satisfied, our algorithm terminates and reports
that all assertions in $G$ are satisfied. If \textsc{BasicChecker}
fails to prove assertions in $\overline{G}$, our algorithm refines the
approximations by unwinding recursive functions and
reiterates~(Algorithm~\ref{algorithm:overview}). 

\begin{algorithm}
  \KwIn{$G = \langle V, E \rangle$ : a control flow graph}
  $k \leftarrow 0$\;
  $G_0 \leftarrow G$\;
  \Repeat{forever}
  {
    \uIf {\textsc{BasicChecker} ($\underline{G}_k$) =
      $\mathit{ErrorTrace} (\tau)$}
    {
      \tcp{find an error trace in the under-approximation $\underline{G}_k$}
      \Return $\mathit{ErrorTrace} (\tau)$\;
    }
    \uElseIf {\textsc{BasicChecker} ($\overline{G}_k$) =
      $\mathit{Pass}$}
    {
      \tcp{prove all assertions in the over-approximation $\overline{G}_k$}
      \Return $\mathit{Pass}$\;
    }
    \uElse {
      $G_{k+1} \leftarrow $ unwind $G_k$\;
      $k \leftarrow k + 1$\;
    }
  }
  \caption{Overview}
  \label{algorithm:overview}
\end{algorithm}

To see how to under approximate computation, consider a control flow
graph $G_k$ with recursive functions $f_0 (\ox_0), f_1 (\ox_1),
\ldots, f_m (\ox_m)$. The under-approximation $\underline{G}_k$ is
obtained by substituting the command $\mathtt{assume\ false}$ for
every command with recursive function calls. The substitution
effectively blocks all recursive invocations. Note that
$\underline{G}_k$ is recursion-free. \textsc{BasicChecker} is able to
check the under-approximation $\underline{G}_k$.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.3\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at (0, 0) {$\ell_s$}; %[label=above:$\mathtt{main()}$]
      \node[node] (1) at (0, -1) {$\ell_1$};
      \node[node] (2) at (0, -2) {$\ell_2$};
      \node[node] (3) at (0, -3) {$\ell_3$};
      \node[node] (4) at (0, -4) {$\ell_e$};

      \path
        (0) edge 
            node [left] {$\mathtt{assume\ n >= 0}$} (1)
        (1) edge 
            node [left] {$\mathtt{assume\ false}$} (2)
        (2) edge 
            node [left] {$\mathtt{assert\ r >= 91}$} (3)
        (3) edge 
            node [left] {$\mathtt{return\ 0}$} (4);
    \end{tikzpicture}
    \caption{$\mathtt{\underline{main}()}$}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{.6\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_e$};

      \path
        (0) edge [bend right=30]
            node [left] {$\mathtt{assume\ n > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(n > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{return\ n - 10}$} (5)
        (2) edge 
            node [right] {$\mathtt{assume\ false}$} (3)
        (3) edge 
            node [right] {$\mathtt{assume\ false}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{return\ t}$} (5);
    \end{tikzpicture}
    \caption{$\mathtt{\underline{mc91}(n)}$}
  \end{subfigure}
  \caption{Under Approximation of McCarthy 91}
  \label{figure:under-mccarthy91}
\end{figure}

