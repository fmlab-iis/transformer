
Let \textsc{BasicChecker} denote a recursion-free inductive program
checker and $G = \langle V, E \rangle$ a control flow graph. Since
non-recursive functions can be replaced by their control flow graphs
after proper variable renaming, we assume that $G$ only contains the
$\mathtt{main()}$ and recursive functions. If $G$ does not contain
recursive functions, \textsc{BasicChecker} is able to check $G$ by
computing inductive invariants.

When $G$ contains recursive functions, we transform $G$ into a
recursion-free program $G^-$. The program $G^-$
under-approximates the computation of $G$. That is, every computation
of $G^-$ is also a computation of $G$. If
\textsc{BasicChecker} finds an error trace in $G^-$, our
algorithm terminates and reports the error trace. Otherwise,
\textsc{BasicChecker} has computed an inductive invariant for the
recursive-free under-approximation $G^-$. Our algorithm
updates function summaries of $G$ from the inductive invariant of
$G^-$. It then checks if every function summary
over-approximations the computation of the corresponding function. If
so, the algorithm terminates and reports that all assertions in $G$
are satisified. If a function summary does not over-approximate the
computation, our algorithm unwind the recursive function and
reiterates~(Algorithm~\ref{algorithm:overview}).

\begin{algorithm}
  \KwIn{$G = \langle V, E \rangle$ : a control flow graph}
  $k \leftarrow 0$\;
  $G_0 \leftarrow G$\;
  \lForEach{function $\mathtt{f}$ in $G$}
  {
    $S[\mathtt{f}] \leftarrow \mathtt{true}$\;
  }
  \Repeat{$\textmd{complete?}$}
  {
    \Switch{\textsc{BasicChecker} ($G^-_k$)}
    {
      \lCase{$\mathit{Pass(\Pi (G^-_k, I_0))}$:}
      {    
        UpdateSummary ($G$, $S$, $\Pi (G^-_k, I_0)$)\;
      }
      \lCase{$\mathit{ErrorTrace} (\tau)$:}
      {
        \Return $\mathit{ErrorTrace} (\tau)$\;
      }
    }
    $\textmd{complete?} \leftarrow \top$\;
    \ForEach{function $\mathtt{f}$ in $G$}
    {
      \lIf {\textsc{BasicChecker} ($\tilde{G}_{\mathtt{f}}$) =
        $\mathit{ErrorTrace}\ \_$}
      {
        $\textmd{complete?} \leftarrow \bot$\;
      }
    }
    $G_{k+1} \leftarrow $ unwind $G_k$\;
    $k \leftarrow k + 1$\;
  }
  \caption{Overview}
  \label{algorithm:overview}
\end{algorithm}

To see how to under approximate computation, consider a control flow
graph $G_k$ with recursive functions $f_0 (\ox_0), f_1 (\ox_1),
\ldots, f_m (\ox_m)$. The under-approximation $G^-_k$ is
obtained by substituting the command $\mathtt{assume\ false}$ for
every command with recursive function calls
(Figure~\ref{figure:under-mccarthy91}). The substitution
effectively blocks all recursive invocations. Any computation of
$G^-_k$ hence is also a computation of $G_k$. Note that
$G^-_k$ is recursion-free. \textsc{BasicChecker} is able to
check the under-approximation $G^-_k$.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.3\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at (0, 0) {$\ell_s$}; %[label=above:$\mathtt{main()}$]
      \node[node] (1) at (0, -1) {$\ell_1$};
      \node[node] (2) at (0, -2) {$\ell_2$};
      \node[node] (3) at (0, -3) {$\ell_3$};
      \node[node] (4) at (0, -4) {$\ell_e$};

      \path
        (0) edge 
            node [left] {$\mathtt{assume\ n >= 0}$} (1)
        (1) edge 
            node [left] {$\mathtt{assume\ false}$} (2)
        (2) edge 
            node [left] {$
              \begin{array}{l}
                \mathtt{assert\ {[}r = 91\ or}\\
                \mathtt{\ \ \ \ \ \ \ \ \ \ \ (n > 101\ and\ \ }\\
                \mathtt{\ \ \ \ \ \ \ \ \ \ \ \ r = n - 10){]}}
              \end{array}$} (3) 
        (3) edge 
            node [left] {$\mathtt{return\ 0}$} (4);
    \end{tikzpicture}
    \caption{$\mathtt{main^-()}$}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{.6\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_e$};

      \path
        (0) edge [bend right=30]
            node [left] {$\mathtt{assume\ m > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(m > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{return\ m - 10}$} (5)
        (2) edge 
            node [right] {$\mathtt{assume\ false}$} (3)
        (3) edge 
            node [right] {$\mathtt{assume\ false}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{return\ t}$} (5);
    \end{tikzpicture}
    \caption{$\mathtt{mc91^-(m)}$}
  \end{subfigure}
  \caption{Under Approximation of McCarthy 91}
  \label{figure:under-mccarthy91}
\end{figure}

When $\textsc{BasicChecker}$ does not find any error trace in the
under-approximation $G^-_k$, it computes an inductive
invariant $\Pi (G^-_k, I_0)$. Our algorithm then updates
summaries of functions in $G$. For each function $\mathtt{f}$ with
formal parameters $\mathtt{u_0}, \mathtt{u_1}, \ldots, \mathtt{u_l}$
and $h$ return values, a \emph{function summary} for $\mathtt{f}$ is a
first-order conjunctive formula which specifies the relation between
its formal parameters and return variables. The algorithm
$\textmd{UpdateSummary}$ updates function summaries $S$ by inspecting
the inductive invariant $\Pi (G^-_k, I_0)$
(Section~\ref{subsection:updating-summary}). 

After function summaries are updated, Algorithm~\ref{algorithm:overview} 
verifies whether function summaries correctly specify computation of
functions. The algorithm checks this by constructing a control flow
graph $\tilde{G}_{\mathtt{f}}$ with additional assertions for each
function $\mathtt{f}$, and verifying $\tilde{G}_{\mathtt{f}}$ with
\textsc{BasicChecker}. The control flow graph
$\tilde{G}_{\mathtt{f}}$ is obtained by substituting function
summaries for function calls.
\hide{
 In Algorithm~\ref{algorithm:overview},
$S[\mathtt{g}]$ contains the function summary for the function
$\mathtt{g}$.  
}
We transform $G_{\mathtt{f}}$ into $\tilde{G}_{\mathtt{f}}$ by the
following three steps:
\begin{enumerate}
\item Replace every function call by instantiating the summary for the
  callee;
\item Replace every return command by assignments to return variables;
\item Add an assertion to validate the summary at the end.
\end{enumerate}
\hide{
\begin{enumerate}
\item Replace every function call $\mathtt{x_1}, \mathtt{x_2}, \ldots,
  \mathtt{x_q} := \mathtt{g} (E_0, E_1, \ldots, E_p)$ in $G_{\mathtt{f}}$ by 
  \begin{equation*}
    \begin{array}{l}
      \mathtt{x_1}, \ldots, \mathtt{x_q} :=
      \mathtt{nondet}, \ldots, \mathtt{nondet};\\
      \mathtt{assume}\ 
      S[{\mathtt{g}}]\{\mathtt{u_0} \mapsto E_0, \ldots, 
      \mathtt{u_p} \mapsto E_p, \mathtt{ret^g_1} \mapsto \mathtt{x_1},
      \ldots, \mathtt{ret^g_q} \mapsto \mathtt{x_q}\}
    \end{array}
  \end{equation*}
  where $\mathtt{u_0}, \mathtt{u_1}, \ldots, \mathtt{u_p}$
  are the formal parameters of the function $\mathtt{g}$;
\item Replace every $\mathtt{return\ }F_1, F_2, \ldots, F_h$ command by
  \begin{equation*}
    \mathtt{ret^f_1}, \ldots, \mathtt{ret^f_h} := F_1, \ldots, F_h
  \end{equation*}
\item Add the command $\mathtt{assert\ }S[{\mathtt{f}}]$ at the end of
  $G_{\mathtt{f}}$. 
\end{enumerate}
}
Figure~\ref{figure:check-summary-mccarthy91} shows the control flow
graph $\tilde{G}_{\mathtt{mc91}}$ with the function summary
$S_{\mathtt{mc91}} = \mathtt{not (m \geq 0)}$. Observe that
$\tilde{G}_{\mathtt{mc91}}$ is
recursion-free. \textsc{BasicChecker} is able to check the
$\tilde{G}_{\mathtt{mc91}}$. 

\begin{figure}
  \centering
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (s) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_5$};
      \node[node] (e) at ( 0, -5) {$\ell_e$};

      \path
        (s) edge [bend right=30]
            node [left] {$\mathtt{assume\ m > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(m > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{ret^{mc91}_0 := m - 10}$} (5)
        (2) edge 
            node [right] {$
              \begin{array}{l}
              \mathtt{s := nondet;}\\
              \mathtt{assume\ not(m + 11 \geq 0)}
              \end{array}
              $} (3)
        (3) edge 
            node [right] {$
              \begin{array}{l}
              \mathtt{t := nondet;}\\
              \mathtt{assume\ not(s \geq 0)}
              \end{array}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{ret^{mc91}_0 := t}$} (5)
        (5) edge 
            node [right] {$\mathtt{assert\ not(m \geq 0)}$} (e)
        ;
    \end{tikzpicture}
  \caption{Check Summary in McCarthy 91}
  \label{figure:check-summary-mccarthy91}
\end{figure}

In order to refine approximations, our algorithm unwinds recursive
functions as usual. More precisely, consider a recursive function
$\mathtt{f}$ with formal parameters $\mathtt{u_0}, \mathtt{u_1},
\ldots, \mathtt{u_l}$ and $h$ return values. Let $G_{\mathtt{f}}$ be
the control flow graph of $\mathtt{f}$ and $G_k$ a control flow graph
that invokes $\mathtt{f}$. To unwind $\mathtt{f}$ in $G_k$, 
we first construct a control flow graph $H_{\mathtt{f}}$ by 
replacing every $\mathtt{return}\ F_1, F_2, \ldots, F_h$ command in
$\mathtt{f}$ with the assignment $\mathtt{ret^f_1}, \mathtt{ret^f_2}, \ldots,
\mathtt{ret^f_h} := F_1, F_2, \ldots, F_h$. For each edge $(\ell,
\ell')$ labeled with the command $\mathtt{x_1}, \mathtt{x_2}, \ldots,
\mathtt{x_h} := \mathtt{f}(E_0, E_1, \ldots, E_l)$ in $G_k$, we remove
the edge $(\ell, \ell')$, make a fresh $H'_{\mathtt{f}}$ by
renaming every nodes and variables in $H_{\mathtt{f}}$, add an edge
from $\ell$ to the entry node of $H'_{\mathtt{f}}$ that assigns $E_0,
E_1, \ldots, E_l$ to fresh copies of formal parameters in
$H'_{\mathtt{f}}$, and another edge from the exit node to $\ell'$ that
assigns fresh copies of return variables to $\mathtt{x_1},
\mathtt{x_2}, \ldots, \mathtt{x_h}$. The control flow graph $G_{k+1}$
is obtained by unwinding every function calls in $G_k$. 
Figure~\ref{figure:unwind-mccarthy91} shows the control flow graph
$\mathtt{mc91_1(m)}$ by unwinding $\mathtt{mc91(m)}$. Note that the
unwinding graph $G_{k+1}$ still has recursive function calls. Its
under approximation $G^-_{k+1}$ however is more informative
than $G^-_k$.

\begin{figure}
  \centering
  \resizebox{.75\textwidth}{!}{
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (s) at (-1,  0) {$\ell_s$};
      \node[node] (1) at (-2, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (e) at (-1, -4) {$\ell_e$};

      \node[node] (s') at ( 5,  2.6) {$\ell_{s'}$};
      \node[node] (1') at ( 4,  0.6) {$\ell_{1'}$};
      \node[node] (2') at ( 6,  1.8) {$\ell_{2'}$};
      \node[node] (3') at ( 6,  0.6) {$\ell_{3'}$};
      \node[node] (4') at ( 6, -0.6) {$\ell_{4'}$};
      \node[node] (e') at ( 5, -1.4) {$\ell_{e'}$};

      \node[node] (s'') at ( 5, -2.6) {$\ell_{s''}$};
      \node[node] (1'') at ( 4, -4.6) {$\ell_{1''}$};
      \node[node] (2'') at ( 6, -3.4) {$\ell_{2''}$};
      \node[node] (3'') at ( 6, -4.6) {$\ell_{3''}$};
      \node[node] (4'') at ( 6, -5.8) {$\ell_{4''}$};
      \node[node] (e'') at ( 5, -6.6) {$\ell_{e''}$};

      \path
        (s) edge [bend right=30]
            node [left] {$
              \begin{array}{c}
                \mathtt{assume}\\ 
                \mathtt{m > 100}                
              \end{array}$} (1)
            edge [bend left=20]
            node [above] {$
              \begin{array}{c}
                \mathtt{assume}\\
                \mathtt{not(m > 100)}
              \end{array}$} (2)
        (1) edge [bend right=30]
            node [left] {$
              \begin{array}{c}
                \mathtt{return}\\
                \mathtt{m - 10}
              \end{array}$} (e)
        (2) edge [bend left=50]
            node [above left] {$\mathtt{m' := m + 11}$} (s')
        (3) edge 
            node [below] {$\mathtt{m'' := s}$} (s'')
        (4) edge [bend left=30]
            node [below] {$\mathtt{return\ t}$} (e)

        (s') edge [bend right=30]
             node [left] {$
               \begin{array}{c}
                 \mathtt{assume}\\
                 \mathtt{m' > 100}
               \end{array}$} (1')
             edge [bend left=30]
             node [right] {$\mathtt{assume\ not(m' > 100)}$} (2')
        (1') edge [bend right=30]
             node [left] {$\mathtt{ret^{mc91'}_0 := m' - 10}$} (e')
        (2') edge 
             node [right] {$\mathtt{s' := mc91(m'+11)}$} (3')
        (3') edge 
             node [right] {$\mathtt{t' := mc91(s')}$} (4')
        (4') edge [bend left=30]
            node [right] {$\mathtt{ret^{mc91'}_0 := t'}$} (e')
        (e') edge 
             node [above] {$\mathtt{s := ret^{mc91'}_0}$} (3)

        (s'') edge [bend right=30]
              node [left] {$\mathtt{assume\ m'' > 100}$} (1'')
              edge [bend left=30]
              node [right] {$\mathtt{assume\ not(m'' > 100)}$} (2'')
        (1'') edge [bend right=30]
              node [left] {$
                \begin{array}{c}
                \mathtt{ret^{mc91''}_0 :=}\\
                \mathtt{m'' - 10}  
                \end{array}
                $} (e'')
        (2'') edge 
              node [right] {$\mathtt{s'' := mc91(m''+11)}$} (3'')
        (3'') edge 
              node [right] {$\mathtt{t'' := mc91(s'')}$} (4'')
        (4'') edge [bend left=30]
              node [right] {$\mathtt{ret^{mc91''}_0 := t''}$} (e'')
        (e'') edge [bend left=50]
              node [below left] {$\mathtt{t := ret^{mc91''}_0}$} (4)
        ;
    \end{tikzpicture}
    }
  \caption{$\mathtt{mc91_1(m)}$}
  \label{figure:unwind-mccarthy91}
\end{figure}

