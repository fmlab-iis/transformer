
Let $\mathtt{Vars}$ denote the set of \emph{program variables} and
$\mathtt{Vars}' = \{ \ox' : \ox \in \mathtt{Vars} \}$.
We consider a variant of the WHILE language~\cite{}:
\begin{equation*}
  \begin{array}{rccll}
    \mathtt{Expression} & \ni E & ::= &
    \mathtt{x} & \mathtt{x} \in \mathtt{Vars}\\
    & & \mid &
    \mathtt{false}\ \mid\ \mathtt{true}\ \mid\ 
    \mathtt{0}\ \mid\ \mathtt{1}\ \mid\ \ldots\hspace{.06\textwidth} &
    \textmd{constant}\\
    & & \mid &
    \mathtt{nondet} & \textmd{nodeterministic value}\\
    & & \mid &
    \mathtt{f}(E, E, \ldots, E) &
    \textmd{function invocation}\\
    & & \mid &
    E \odot E  & \odot \in \{ +, -, =, >, \mathtt{and}, \mathtt{or} \}\\
    & & \mid & \mathtt{not}\ E\\
    \mathtt{Command} & \ni C & ::= &
    \mathtt{x}, \mathtt{x}, \ldots, \mathtt{x} := 
    E, E, \ldots, E & \textmd{assignment}\\
    & & \mid &
    C\mathtt{;}\ C &
    \textmd{sequential composition}\\
    & & \mid &
    \mathtt{return}\ E, E, \ldots, E & \textmd{function return}\\
    & & \mid &
    \mathtt{assume}\ E & \textmd{assumption}\\
    & & \mid &
    \mathtt{assert}\ E & \textmd{assertion}
  \end{array}
\end{equation*}
The $\mathtt{nondet}$ expression evaluates to a type-safe
nondeterministic value.
Note that simultaneous assignments are allowed in our language. To
execute a simultaneous assignment, all expressions on the right hand
side are first evaluated and then assign to respective variables. 
The $\mathtt{return}$ command accepts several expressions as arguments.
Together with simultaneous assignments, functions can have several
return values. 

A function $\fun{f}$ is represented as a \emph{control flow graph (CFG)} $G_\fun{f} = \langle
V, E,\textmd{cmd},\overline{u}, \overline{r},  \ell_s,  \ell_e\rangle$ where the nodes in $V$ are \emph{program locations},
each edge $(\ell, \ell')$ in $E \subseteq V \times V$ is labeled by a
command denoted by $\textmd{cmd} (\ell, \ell')$, $\overline{u}$ and $\overline{r}$ are \emph{formal parameters} and \emph{return variables} of $\fun{f}$, and $\ell_s,  \ell_e \in V$ are the \emph{entry} and \emph{exit} locations of $\fun{f}$. The subscripted name in $G_\fun{f}$ denotes the CFG corresponds to the function $\fun{f}$.
The special $\mathtt{main}$ function specifies where a program starts.
For a sequence of variables $\overline{x}$, we use $x_i$ to denote its $i$-th element. To simplify presentation, we assume the functions in the programs uses disjoint sets of variables and the values of formal parameters never change in a function. Notice that this will not affect the expressiveness of a CFG because one can still make copies of formal parameters by assignments and change the values of the copied versions. Also we assume that there exist no global variables because they can be simulated by allowing simultaneous assignment to return variables. 

Figure~\ref{figure:mccarthy91} shows control flow graphs for the
McCarthy 91 program. The $\mathtt{main}$ function assumes the
variable $\mathtt{n}$ is non-negative. It then checks if the return
value of $\mathtt{mc91(n)}$ is no less than 90
(Figure~\ref{figure:mccarthy91:main}). The $\mathtt{mc91}$ function
branches on whether the variable $\mathtt{m}$ is greater than 100. If
so, the it returns the value $\mathtt{m} -
10$. Otherwise, 
$\mathtt{mc91(m)}$ assigns the return value of $\mathtt{mc91(m + 11)}$
to $\mathtt{s}$, and updates its own return value by calling
$\mathtt{mc91(s)}$ recursively
(Figure~\ref{figure:mccarthy91:mc91}). Observe that the 
$\mathtt{assume}$ command models a conditional branch in the
figure. Loops can be modeled similarly.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.3\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at (0, 0) {$\ell_s$}; %[label=above:$\mathtt{main()}$]
      \node[node] (1) at (0, -1) {$\ell_1$};
      \node[node] (2) at (0, -2) {$\ell_2$};
      \node[node] (3) at (0, -3) {$\ell_3$};
      \node[node] (4) at (0, -4) {$\ell_e$};

      \path
        (0) edge 
            node [left] {$\mathtt{assume\ n >= 0}$} (1)
        (1) edge 
            node [left] {$\mathtt{r := mc91(n)}$} (2)
        (2) edge 
            node [left] {$
              \begin{array}{l}
                \mathtt{assert\ {[}r = 91\ or}\\
                \mathtt{\ \ \ \ \ \ \ \ \ \ \ (n > 101\ and\ \ }\\
                \mathtt{\ \ \ \ \ \ \ \ \ \ \ \ r = n - 10){]}}
              \end{array}$} (3) 
        (3) edge 
            node [left] {$\mathtt{return\ 0}$} (4);
    \end{tikzpicture}
    \caption{$\mathtt{main}$}
    \label{figure:mccarthy91:main}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{.6\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at ( 0,  0) {$\ell_{s'}$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_{1'}$};
      \node[node] (2) at ( 1, -0.8) {$\ell_{2'}$};
      \node[node] (3) at ( 1, -2) {$\ell_{3'}$};
      \node[node] (4) at ( 1, -3.2) {$\ell_{4'}$};
      \node[node] (5) at ( 0, -4) {$\ell_{e'}$};

      \path
        (0) edge [bend right=30]
            node [left] {$\mathtt{assume\ m > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(m > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{return\ m - 10}$} (5)
        (2) edge 
            node [right] {$\mathtt{s := mc91(m + 11)}$} (3)
        (3) edge 
            node [right] {$\mathtt{t := mc91(s)}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{return\ t}$} (5);
    \end{tikzpicture}
    \caption{$\mathtt{mc91}$}
    \label{figure:mccarthy91:mc91}
  \end{subfigure}
  \caption{McCarthy 91}
  \label{figure:mccarthy91}
\end{figure}

%\todo{definitions of accessible variables, program states}
Let $G = \langle V, E ,\textmd{cmd},\overline{u}, \overline{r},  \ell_s,  \ell_e\rangle$ be a CFG.
An \emph{inductive invariant} $\Pi (G, I_0) = \{ I_\ell : \ell \in V
\}$ for $G$ from $I_0$ is a set of first-order logic formulae such
that $I_{\ell_s} = I_0$, and for every $(\ell, \ell') \in E$
\begin{equation*}
I_{\ell} \wedge \tau_{\textmd{cmd}(\ell, \ell')} \implies I'_{\ell'}
\end{equation*}
where $I'$ is the formula obtained by replacing every $\ox \in
\mathtt{Vars}$ in $I$ with $\ox' \in \mathtt{Vars}'$, and
$\tau_{\textmd{cmd} (e)}$ specifies the semantics of the command
$\textmd{cmd} (e)$. An inductive invariant $\Pi (G, I_0)$ is an
over-approximation to the computation of $G$ from $I_0$. More
precisely, assume that the function $G$ starts from a state satisfying
$I_0$. For every program location $\ell$, $G$ must arrive in a state
satisfying $I_{\ell}$ when the computation reaches $\ell$. 

Let $T$ be a program fragment (it can be either a function represented as a CFG or a sequence of program commands), and $P$, $Q$
are logic formulae. A \emph{Hoare triple} $\assert{P} T \assert{Q}$
specifies that the program fragment $T$ will reach a program state satisfying
$Q$ provided that $T$ starts with a program state satisfying $P$ and
terminates. The formula $P$ is called the \emph{precondition} and $Q$ is the \emph{postcondition} of the Hoare triple. We use the standard proof rules for weak correctness with
two additional rules for the assumption and assertion commands:
\begin{center}
  \AxiomC{}
  \LeftLabel{Assume}
  \UnaryInfC{$\assert{P} \mathtt{assume\ } E \assert{P \wedge E}$}
  \DisplayProof
  ~
  \AxiomC{$P \implies E$}
  \LeftLabel{Assert}
  \UnaryInfC{$\assert{P} \mathtt{assert\ } E \assert{P}$}
  \DisplayProof
\end{center}
The assumption command excludes all computation not satisfying the given
expression. The assert command terminates computation
abnormally if the given expression is not implied by the precondition. No postcondition can be guaranteed in such a case.
%For instance, the following command always terminates normally:
%\begin{equation*}
% \mathtt{assume\ false};\ \ \mathtt{assert\ false}
%\end{equation*}
Observe
that an inductive invariant $\Pi (G, I_0)$ establishes 
$\assert{I_0} G \assert{I_{\ell_e}}$.

A \emph{program analyzer} accepts programs as inputs and
checks if all assertions (specified by the $\mathtt{assert}$ command)
are satisfied. One way to implement program analyzers is to compute
inductive invariants. 
\begin{proposition}
Let $G = \langle V, E,\textmd{cmd},\overline{u}, \overline{r},  \ell_s,  \ell_e \rangle$ be a control flow
graph and $\Pi (G, \mathtt{true})$ an inductive invariant for $G$ from
$\mathtt{true}$. If $\models I_{\ell} \implies B_{\ell}$ for every
edge $(\ell, \ell') \in E$ with $\textmd{cmd} (\ell, \ell') =
\mathtt{assert} (B_{\ell})$, then all assertions in $G$ are satisfied.
\label{proposition:inductive-invariant}
\end{proposition}
A program analyzer checks assertions by computing inductive invariants
is called an \emph{inductive} program analyzer. Note that an inductive
program analyzer need not give any information when an assertion fails. 
Indeed, most inductive program analyzers simply report false positives
when inductive invariants are too coarse. A \emph{program checker} is
a program analyzer that returns an error trace when an assertion
fails; an \emph{error trace} is a sequence of variable valuations from
the program entry to the failed assertion. Rather than reporting false
positives, program checkers have to return error traces to witness 
failed assertions. Producing error traces (especially for recursive
programs) complicates analysis algorithms. We hence consider a
subclass of program checker. A \emph{recursion-free
  inductive program checker} is a program checker that checks
recursion-free programs by computing inductive invariants, and reports
an error trace when an assertion fails. Several recursion-free
inductive program checkers are available such as \textsc{CPAChecker},
\textsc{Blast}, \textsc{UFO}. Our goal is to check
recursive programs by using a recursion-free inductive program analyzer
as a black box. 
