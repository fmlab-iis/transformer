
Let $\mathtt{Vars}$ denote the set of \emph{program variables} and
$\mathtt{Vars}' = \{ \ox' : \ox \in \mathtt{Vars} \}$.
We consider a variant of the WHILE language~\cite{}:
\begin{equation*}
  \begin{array}{rccll}
    \mathtt{Expression} & \ni E & ::= &
    \mathtt{x} & \mathtt{x} \in \mathtt{Vars}\\
    & & \mid &
    \mathtt{false}\ \mid\ \mathtt{true}\ \mid\ 
    \mathtt{0}\ \mid\ \mathtt{1}\ \mid\ \ldots\hspace{.06\textwidth} &
    \textmd{constant}\\
    & & \mid &
    \mathtt{nondet} & \textmd{nodeterministic value}\\
    & & \mid &
    \mathtt{f}(E, E, \ldots, E) &
    \textmd{function invocation}\\
    & & \mid &
    E \odot E  & \odot \in \{ +, -, =, >, \mathtt{and}, \mathtt{or} \}\\
    & & \mid & \mathtt{not}\ E\\
    \mathtt{Command} & \ni C & ::= &
    \mathtt{x}, \mathtt{x}, \ldots, \mathtt{x} := 
    E, E, \ldots, E & \textmd{assignment}\\
    & & \mid &
    C\mathtt{;}\ C &
    \textmd{sequential composition}\\
    & & \mid &
    \mathtt{return}\ E, E, \ldots, E & \textmd{function return}\\
    & & \mid &
    \mathtt{assume}\ E & \textmd{assumption}\\
    & & \mid &
    \mathtt{assert}\ E & \textmd{assertion}
  \end{array}
\end{equation*}
The $\mathtt{nondet}$ expression evaluates to a type-safe
nondeterministic value.
Note that simultaneous assignments are allowed in our language. To
execute a simultaneous assignment, all expressions on the right hand
side are first evaluated and then assign to respective variables. 
The $\mathtt{return}$ command accepts several expressions as arguments.
Together with simultaneous assignments, functions can have several
return values. 
The assumption command excludes all computation not satisfying the given
expression. The assert command terminates computation
abnormally if the given expression is not satisfied. For
instance, the following command always terminates normally:
\begin{equation*}
  \mathtt{assume\ false};\ \ \mathtt{assert\ false}
\end{equation*}
\todo{no computation means terminate normally?}




A function is represented as a \emph{control flow graph} $G = \langle
V, E,\textmd{cmd} \rangle$ where the nodes in $V$ are \emph{program locations}, and
each edge $(\ell, \ell')$ in $E \subseteq V \times V$ is labeled by a
command denoted by $\textmd{cmd} (\ell, \ell')$. We
assume that the program locations $\ell_s$ and $\ell_e$ denote the
entry and exit of each function. Moreover, the special
$\mathtt{main()}$ function specifies where a program starts.
We use $G_f=\langle
V_f, E_f,\textmd{cmd}_f \rangle$ to denotes the CFG corresponds to a the function $\mathtt{f}$.
Figure~\ref{figure:mccarthy91} shows control flow graphs for the
McCarthy 91 program. The $\mathtt{main()}$ function assumes the
variable $\mathtt{n}$ is non-negative. It then checks if the return
value of $\mathtt{mc91(n)}$ is no less than 90
(Figure~\ref{figure:mccarthy91:main}). The $\mathtt{mc91(m)}$ function
branches on whether the variable $\mathtt{m}$ is greater than 100. If
so, the return value $\mathtt{ret^{mc91}_0}$ is set to $\mathtt{m} -
10$. Otherwise, 
$\mathtt{mc91(m)}$ assigns the return value of $\mathtt{mc91(m + 11)}$
to $\mathtt{s}$, and updates $\mathtt{ret^{mc91}_0}$ by calling
$\mathtt{mc91(s)}$ recursively
(Figure~\ref{figure:mccarthy91:mc91}). Observe that the 
$\mathtt{assume}$ command models a conditional branch in the
figure. Loops can be modeled similarly.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.3\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at (0, 0) {$\ell_s$}; %[label=above:$\mathtt{main()}$]
      \node[node] (1) at (0, -1) {$\ell_1$};
      \node[node] (2) at (0, -2) {$\ell_2$};
      \node[node] (3) at (0, -3) {$\ell_3$};
      \node[node] (4) at (0, -4) {$\ell_e$};

      \path
        (0) edge 
            node [left] {$\mathtt{assume\ n >= 0}$} (1)
        (1) edge 
            node [left] {$\mathtt{r := mc91(n)}$} (2)
        (2) edge 
            node [left] {$
              \begin{array}{l}
                \mathtt{assert\ {[}r = 91\ or}\\
                \mathtt{\ \ \ \ \ \ \ \ \ \ \ (n > 101\ and\ \ }\\
                \mathtt{\ \ \ \ \ \ \ \ \ \ \ \ r = n - 10){]}}
              \end{array}$} (3) 
        (3) edge 
            node [left] {$\mathtt{return\ 0}$} (4);
    \end{tikzpicture}
    \caption{$\mathtt{main()}$}
    \label{figure:mccarthy91:main}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{.6\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_e$};

      \path
        (0) edge [bend right=30]
            node [left] {$\mathtt{assume\ m > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(m > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{return\ m - 10}$} (5)
        (2) edge 
            node [right] {$\mathtt{s := mc91(m + 11)}$} (3)
        (3) edge 
            node [right] {$\mathtt{t := mc91(s)}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{return\ t}$} (5);
    \end{tikzpicture}
    \caption{$\mathtt{mc91(m)}$}
    \label{figure:mccarthy91:mc91}
  \end{subfigure}
  \caption{McCarthy 91}
  \label{figure:mccarthy91}
\end{figure}

\todo{definitions of accessible variables, program states}
Let $G = \langle V, E ,\textmd{cmd}\rangle$ be a control flow graph.
An \emph{inductive invariant} $\Pi (G, I_0) = \{ I_\ell : \ell \in V
\}$ for $G$ from $I_0$ is a set of first-order logic formulae such
that $I_{\ell_s} = I_0$, and for every $(\ell, \ell') \in E$
\begin{equation*}
I_{\ell} \wedge \tau_{\textmd{cmd}(\ell, \ell')} \implies I'_{\ell'}
\end{equation*}
where $I'$ is the formula obtained by replacing every $\ox \in
\mathtt{Vars}$ in $I$ with $\ox' \in \mathtt{Vars}'$, and
$\tau_{\textmd{cmd} (e)}$ specifies the semantics of the command
$\textmd{cmd} (e)$. An inductive invariant $\Pi (G, I_0)$ is an
over-approximation to the computation of $G$ from $I_0$. More
precisely, assume that the function $G$ starts from a state satisfying
$I_0$. For every program location $\ell$, $G$ must arrive in a state
satisfying $I_{\ell}$ when the computation reaches $\ell$. 

Let $G = \langle V, E,\textmd{cmd} \rangle$ be a control flow graph, and $P$, $Q$
are logic formulae. A \emph{Hoare triple} $\assert{P} G \assert{Q}$
specifies that the program $G$ will reach a program state satisfying
$Q$ provided that $G$ starts with a program state satisfying $P$ and
terminates. We use the standard proof rules for weak correctness with
two additional rules for the assumption and assertion commands:
\begin{center}
  \AxiomC{$P \wedge E \implies Q$}
  \LeftLabel{Assume}
  \UnaryInfC{$\assert{P} \mathtt{assume\ } E \assert{Q}$}
  \DisplayProof
  ~
  \AxiomC{$P \implies E$}
  \LeftLabel{Assert}
  \UnaryInfC{$\assert{P} \mathtt{assert\ } E \assert{Q}$}
  \DisplayProof
\end{center}
Observe
that an inductive invariant $\Pi (G, I_0)$ establishes 
$\assert{I_0} G \assert{I_{\ell_e}}$.

A \emph{program analyzer} accepts programs as inputs and
checks if all assertions (specified by the $\mathtt{assert}$ command)
are satisfied. One way to implement program analyzers is to compute
inductive invariants. 
\begin{proposition}
Let $G = \langle V, E,\textmd{cmd} \rangle$ be a control flow
graph and $\Pi (G, \mathtt{true})$ an inductive invariant for $G$ from
$\mathtt{true}$. If $\models I_{\ell} \implies B_{\ell}$ for every
edge $(\ell, \ell') \in E$ with $\textmd{cmd} (\ell, \ell') =
\mathtt{assert} (B_{\ell})$, then all assertions in $G$ are satisfied.
\label{proposition:inductive-invariant}
\end{proposition}
A program analyzer checks assertions by computing inductive invariants
is called an \emph{inductive} program analyzer. Note that an inductive
program analyzer need not give any information when an assertion fails. 
Indeed, most inductive program analyzers simply report false positives
when inductive invariants are too coarse. A \emph{program checker} is
a program analyzer that returns an error trace when an assertion
fails; an \emph{error trace} is a sequence of variable valuations from
the program entry to the failed assertion. Rather than reporting false
positives, program checkers have to return error traces to witness 
failed assertions. Producing error traces (especially for recursive
programs) complicates analysis algorithms. We hence consider a
subclass of program checker. A \emph{recursion-free
  inductive program checker} is a program checker that checks
recursion-free programs by computing inductive invariants, and reports
an error trace when an assertion fails. Several recursion-free
inductive program checkers are available such as \textsc{CPAChecker},
\textsc{Blast}, \textsc{UFO}, \textsc{}. Our goal is to check
recursive programs by using a recursion-free inductive program checker
as a black box. 
