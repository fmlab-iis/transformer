
Let $\mathtt{Vars}$ denote the set of \emph{program variables} and
$\mathtt{Vars}' = \{ \ox' : \ox \in \mathtt{Vars} \}$.
We consider a variant of the WHILE language~\cite{}:
\begin{equation*}
  \begin{array}{rccll}
    \mathtt{Expression} & \ni E & ::= &
    \mathtt{x} & \mathtt{x} \in \mathtt{Vars}\\
    & & \mid &
    \mathtt{false}\ \mid\ \mathtt{true}\ \mid\ 
    \mathtt{0}\ \mid\ \mathtt{1}\ \mid\ \ldots\hspace{.06\textwidth} &
    \textmd{constant}\\
    & & \mid &
    E \odot E  & \odot \in \{ +, -, =, >, \mathtt{and} \}\\
    & & \mid & \mathtt{not}\ E\\
    & & \mid &
    \mathtt{f}(E, E, \ldots, E) &
    \textmd{function invocation}\\
    \mathtt{Command} & \ni C & ::= &
    \mathtt{x}, \mathtt{x}, \ldots, \mathtt{x} := 
    E, E, \ldots, E & \textmd{assignment}\\
    & & \mid &
    \mathtt{assume}\ E & \textmd{assumption}\\
    & & \mid &
    \mathtt{assert}\ E & \textmd{assertion}\\
    & & \mid &
    \mathtt{return}\ E, E, \ldots, E & \textmd{function return}\\
  \end{array}
\end{equation*}
Note that simultaneous assignments are allowed in our language. To
execute a simultaneous assignment, all expressions on the right hand
side are first evaluated and then assign to respective variables. The
assumption command excludes all computation not satisfying the given
expression. The assert command terminates computation
abnormally if the given expression is not satisfied. For
instance, the following command always terminates normally:
\begin{equation*}
  \mathtt{assume\ false};\ \ \mathtt{assert\ false}
\end{equation*}
\todo{no computation means terminate normally?}
Our simple language also allows functions to return multiple
values. Together with simultaneous assignments, functions can update
several variables at once.

A function is represented as a \emph{control flow graph} $G = \langle
V, E \rangle$ where the nodes in $V$ are \emph{program locations}, and
each edge $(\ell, \ell')$ in $E \subseteq V \times V$ is labeled by a
command denoted by $\textmd{cmd} (\ell, \ell')$. We
assume that the program locations $\ell_s$ and $\ell_e$ denote the
entry and exit of each function. Moreover, the special
$\mathtt{main()}$ function specifies where a program starts.
Figure~\ref{figure:mccarthy91} shows control flow graphs for the
McCarthy 91 program. The $\mathtt{main()}$ function assumes the
variable $\mathtt{n}$ is non-negative. It then checks
$\mathtt{mc91(n)}$ is no less than 90
(Figure~\ref{figure:mccarthy91:main}). The $\mathtt{mc91(n)}$ function
branches on whether the variable $\mathtt{n}$ is greater than 100. If
so, $\mathtt{mc91(n)}$ returns $\mathtt{n} - 10$. Otherwise,
$\mathtt{mc91(n)}$ returns $\mathtt{mc91(mc91(n + 11))}$
(Figure~\ref{figure:mccarthy91:mc91}). Observe that the
$\mathtt{assume}$ command models a conditional branch in the
figure. Loops can be modeled similarly.

\begin{figure}
  \centering
  \begin{subfigure}[b]{.3\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at (0, 0) {$\ell_s$}; %[label=above:$\mathtt{main()}$]
      \node[node] (1) at (0, -1) {$\ell_1$};
      \node[node] (2) at (0, -2) {$\ell_2$};
      \node[node] (3) at (0, -3) {$\ell_3$};
      \node[node] (4) at (0, -4) {$\ell_e$};

      \path
        (0) edge 
            node [left] {$\mathtt{assume\ n >= 0}$} (1)
        (1) edge 
            node [left] {$\mathtt{r\ :=\ mc91(n)}$} (2)
        (2) edge 
            node [left] {$\mathtt{assert\ r >= 91}$} (3)
        (3) edge 
            node [left] {$\mathtt{return\ 0}$} (4);
    \end{tikzpicture}
    \caption{$\mathtt{main()}$}
    \label{figure:mccarthy91:main}
  \end{subfigure}
  ~
  \begin{subfigure}[b]{.6\textwidth}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2cm,thick,node/.style={circle,draw}]
      \node[node] (0) at ( 0,  0) {$\ell_s$}; %[label=above:$\mathtt{mc91(n)}$]
      \node[node] (1) at (-1, -2) {$\ell_1$};
      \node[node] (2) at ( 1, -0.8) {$\ell_2$};
      \node[node] (3) at ( 1, -2) {$\ell_3$};
      \node[node] (4) at ( 1, -3.2) {$\ell_4$};
      \node[node] (5) at ( 0, -4) {$\ell_e$};

      \path
        (0) edge [bend right=30]
            node [left] {$\mathtt{assume\ n > 100}$} (1)
            edge [bend left=30]
            node [right] {$\mathtt{assume\ not(n > 100)}$} (2)
        (1) edge [bend right=30]
            node [left] {$\mathtt{return\ n - 10}$} (5)
        (2) edge 
            node [right] {$\mathtt{s\ :=\ m91(n + 11)}$} (3)
        (3) edge 
            node [right] {$\mathtt{t\ :=\ m91(s)}$} (4)
        (4) edge [bend left=30]
            node [right] {$\mathtt{return\ t}$} (5);
    \end{tikzpicture}
    \caption{$\mathtt{mc91(n)}$}
    \label{figure:mccarthy91:mc91}
  \end{subfigure}
  \caption{McCarthy 91}
  \label{figure:mccarthy91}
\end{figure}

\todo{definitions of accessible variables, program states}
Let $G = \langle V, E \rangle$ be a control flow graph.
An \emph{inductive invariant} $\Pi (G, I_0) = \{ I_\ell : \ell \in V
\}$ for $G$ from $I_0$ is a set of first-order logic formulae such
that $I_{\ell_s} = I_0$, and for every $(\ell, \ell') \in E$
\begin{equation*}
I_{\ell} \wedge \tau_{\textmd{cmd}(\ell, \ell')} \implies I'_{\ell'}
\end{equation*}
where $I'$ is the formula obtained by replacing every $\ox \in
\mathtt{Vars}$ in $I$ with $\ox' \in \mathtt{Vars}'$, and
$\tau_{\textmd{cmd} (e)}$ specifies the semantics of the command
$\textmd{cmd} (e)$. An inductive invariant $\Pi (G, I_0)$ is an
over-approximation to the computation of $G$ from $I_0$. More
precisely, assume that the function $G$ starts from a state satisfying
$I_0$. For every program location $\ell$, $G$ must arrive in a state
satisfying $I_{\ell}$ when the computation reaches $\ell$. Observe
that an inductive invariant $\Pi (G, I_0)$ establishes the weak
correctness for the Hoare triple $\{ I_0 \} G \{ I_{\ell_e} \}$.

A \emph{program analyzer} accepts programs as inputs and
checks if all assertions (specified by the $\mathtt{assert}$ command)
are satisfied. One way to implement program analyzers is to compute
inductive invariants. 
\begin{proposition}
Let $G = \langle V, E \rangle$ be a control flow
graph and $\Pi (G, \mathtt{true})$ an inductive invariant for $G$ from
$\mathtt{true}$. If $\models I_{\ell} \implies B_{\ell}$ for every
edge $(\ell, \ell') \in E$ with $\textmd{cmd} (\ell, \ell') =
\mathtt{assert} (B_{\ell})$, then all assertions in $G$ are satisfied.
\end{proposition}
A program analyzer checks assertions by computing inductive invariants
is called an \emph{inductive} program analyzer. Note that an inductive
program analyzer need not give any information when an assertion fails. 
Indeed, most inductive program analyzers simply report false positives
when inductive invariants are too coarse. A \emph{program checker} is
a program analyzer that returns an error trace when an assertion
fails; an \emph{error trace} is a sequence of variable valuations from
the program entry to the failed assertion. Rather than reporting false
positives, program checkers have to return error traces to witness 
failed assertions. Producing error traces (especially for recursive
programs) complicates analysis algorithms. We hence consider a
subclass of program checker. A \emph{recursion-free
  inductive program checker} is a program checker that checks
recursion-free programs by computing inductive invariants, and reports
an error trace when an assertion fails. Several recursion-free
inductive program checkers are available such as \textsc{CPAChecker},
\textsc{Blast}, \textsc{SLAM} \todo{more?}. Our goal is to check
recursive programs by using a recursion-free inductive program checker
as a black box. 
